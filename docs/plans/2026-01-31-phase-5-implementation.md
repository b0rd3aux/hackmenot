# Phase 5: Dependency Scanning + Documentation - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add dependency security scanning (hallucinated packages, typosquatting, CVEs) and comprehensive v1.0 documentation.

**Architecture:** New `deps` module with parser, hallucination detector, typosquat detector, and OSV API client. Bundled top-50K package lists for PyPI/npm. Seven documentation files covering all features.

**Tech Stack:** Python 3.11+, requests (for OSV API), Levenshtein distance algorithm

---

## Task 1: Create Package Database Files

**Files:**
- Create: `src/hackmenot/data/__init__.py`
- Create: `src/hackmenot/data/pypi_top50k.txt`
- Create: `src/hackmenot/data/npm_top50k.txt`
- Create: `scripts/update-package-lists.py`

**Step 1: Create data module**

Create `src/hackmenot/data/__init__.py`:
```python
"""Package database for dependency scanning."""

from pathlib import Path

DATA_DIR = Path(__file__).parent


def load_package_set(ecosystem: str) -> set[str]:
    """Load package names for an ecosystem into a set."""
    filename = f"{ecosystem.lower()}_top50k.txt"
    filepath = DATA_DIR / filename
    if not filepath.exists():
        return set()
    return set(filepath.read_text().strip().lower().split("\n"))
```

**Step 2: Create PyPI package list**

Create `src/hackmenot/data/pypi_top50k.txt` with top packages (one per line, lowercase):
```
requests
numpy
pandas
django
flask
...
```

Note: For now, include top ~1000 packages. Full 50K will be generated by script.

**Step 3: Create npm package list**

Create `src/hackmenot/data/npm_top50k.txt` with top packages:
```
lodash
react
express
axios
typescript
...
```

**Step 4: Create generation script**

Create `scripts/update-package-lists.py`:
```python
#!/usr/bin/env python3
"""Script to update package lists from registries."""

import json
import urllib.request
from pathlib import Path


def fetch_pypi_top_packages(limit: int = 50000) -> list[str]:
    """Fetch top PyPI packages by download count."""
    # Use PyPI stats API or BigQuery
    # For now, return empty - manual curation needed
    print(f"TODO: Implement PyPI fetch for {limit} packages")
    return []


def fetch_npm_top_packages(limit: int = 50000) -> list[str]:
    """Fetch top npm packages by download count."""
    # Use npm registry API
    print(f"TODO: Implement npm fetch for {limit} packages")
    return []


if __name__ == "__main__":
    data_dir = Path(__file__).parent.parent / "src" / "hackmenot" / "data"

    # PyPI
    pypi_packages = fetch_pypi_top_packages()
    if pypi_packages:
        (data_dir / "pypi_top50k.txt").write_text("\n".join(pypi_packages))
        print(f"Wrote {len(pypi_packages)} PyPI packages")

    # npm
    npm_packages = fetch_npm_top_packages()
    if npm_packages:
        (data_dir / "npm_top50k.txt").write_text("\n".join(npm_packages))
        print(f"Wrote {len(npm_packages)} npm packages")
```

**Step 5: Commit**

```bash
git add src/hackmenot/data/ scripts/
git commit -m "feat: add package database for dependency scanning"
```

---

## Task 2: Create Dependency Parser

**Files:**
- Create: `src/hackmenot/deps/__init__.py`
- Create: `src/hackmenot/deps/parser.py`
- Create: `tests/test_deps/__init__.py`
- Create: `tests/test_deps/test_parser.py`

**Step 1: Write failing tests**

Create `tests/test_deps/test_parser.py`:
```python
"""Tests for dependency file parser."""

from pathlib import Path

import pytest

from hackmenot.deps.parser import DependencyParser, Dependency


class TestRequirementsTxt:
    """Tests for requirements.txt parsing."""

    def test_parse_simple_requirement(self, tmp_path: Path):
        """Test parsing simple package name."""
        req_file = tmp_path / "requirements.txt"
        req_file.write_text("requests\n")

        parser = DependencyParser()
        deps = parser.parse_requirements_txt(req_file)

        assert len(deps) == 1
        assert deps[0].name == "requests"
        assert deps[0].version is None

    def test_parse_requirement_with_version(self, tmp_path: Path):
        """Test parsing package with version specifier."""
        req_file = tmp_path / "requirements.txt"
        req_file.write_text("requests==2.28.0\n")

        parser = DependencyParser()
        deps = parser.parse_requirements_txt(req_file)

        assert len(deps) == 1
        assert deps[0].name == "requests"
        assert deps[0].version == "2.28.0"

    def test_parse_multiple_requirements(self, tmp_path: Path):
        """Test parsing multiple packages."""
        req_file = tmp_path / "requirements.txt"
        req_file.write_text("requests>=2.0\nflask==2.0.1\ndjango\n")

        parser = DependencyParser()
        deps = parser.parse_requirements_txt(req_file)

        assert len(deps) == 3
        names = [d.name for d in deps]
        assert "requests" in names
        assert "flask" in names
        assert "django" in names

    def test_skip_comments_and_blank_lines(self, tmp_path: Path):
        """Test that comments and blank lines are skipped."""
        req_file = tmp_path / "requirements.txt"
        req_file.write_text("# Comment\nrequests\n\n# Another comment\nflask\n")

        parser = DependencyParser()
        deps = parser.parse_requirements_txt(req_file)

        assert len(deps) == 2


class TestPackageJson:
    """Tests for package.json parsing."""

    def test_parse_dependencies(self, tmp_path: Path):
        """Test parsing package.json dependencies."""
        pkg_file = tmp_path / "package.json"
        pkg_file.write_text('{"dependencies": {"lodash": "^4.17.0", "express": "4.18.0"}}')

        parser = DependencyParser()
        deps = parser.parse_package_json(pkg_file)

        assert len(deps) == 2
        names = [d.name for d in deps]
        assert "lodash" in names
        assert "express" in names

    def test_parse_dev_dependencies(self, tmp_path: Path):
        """Test parsing devDependencies."""
        pkg_file = tmp_path / "package.json"
        pkg_file.write_text('{"devDependencies": {"jest": "^29.0.0"}}')

        parser = DependencyParser()
        deps = parser.parse_package_json(pkg_file)

        assert len(deps) == 1
        assert deps[0].name == "jest"

    def test_parse_both_dependency_types(self, tmp_path: Path):
        """Test parsing both dependencies and devDependencies."""
        pkg_file = tmp_path / "package.json"
        pkg_file.write_text(
            '{"dependencies": {"react": "18.0.0"}, "devDependencies": {"typescript": "5.0.0"}}'
        )

        parser = DependencyParser()
        deps = parser.parse_package_json(pkg_file)

        assert len(deps) == 2


class TestPyprojectToml:
    """Tests for pyproject.toml parsing."""

    def test_parse_dependencies(self, tmp_path: Path):
        """Test parsing pyproject.toml dependencies."""
        pyproject = tmp_path / "pyproject.toml"
        pyproject.write_text(
            '[project]\ndependencies = ["requests>=2.0", "click"]\n'
        )

        parser = DependencyParser()
        deps = parser.parse_pyproject_toml(pyproject)

        assert len(deps) == 2
        names = [d.name for d in deps]
        assert "requests" in names
        assert "click" in names


class TestAutoDetect:
    """Tests for automatic dependency file detection."""

    def test_detect_requirements_txt(self, tmp_path: Path):
        """Test auto-detection of requirements.txt."""
        (tmp_path / "requirements.txt").write_text("requests\n")

        parser = DependencyParser()
        deps = parser.parse_directory(tmp_path)

        assert len(deps) == 1
        assert deps[0].ecosystem == "pypi"

    def test_detect_package_json(self, tmp_path: Path):
        """Test auto-detection of package.json."""
        (tmp_path / "package.json").write_text('{"dependencies": {"lodash": "4.0.0"}}')

        parser = DependencyParser()
        deps = parser.parse_directory(tmp_path)

        assert len(deps) == 1
        assert deps[0].ecosystem == "npm"

    def test_detect_multiple_files(self, tmp_path: Path):
        """Test detecting multiple dependency files."""
        (tmp_path / "requirements.txt").write_text("requests\n")
        (tmp_path / "package.json").write_text('{"dependencies": {"lodash": "4.0.0"}}')

        parser = DependencyParser()
        deps = parser.parse_directory(tmp_path)

        assert len(deps) == 2
```

**Step 2: Create deps module**

Create `src/hackmenot/deps/__init__.py`:
```python
"""Dependency scanning module."""

from hackmenot.deps.parser import Dependency, DependencyParser

__all__ = ["Dependency", "DependencyParser"]
```

**Step 3: Implement parser**

Create `src/hackmenot/deps/parser.py`:
```python
"""Parser for dependency files."""

import json
import re
from dataclasses import dataclass
from pathlib import Path


@dataclass
class Dependency:
    """A parsed dependency."""

    name: str
    version: str | None
    ecosystem: str  # "pypi" or "npm"
    source_file: str


class DependencyParser:
    """Parser for various dependency file formats."""

    def parse_directory(self, directory: Path) -> list[Dependency]:
        """Auto-detect and parse all dependency files in a directory."""
        deps: list[Dependency] = []

        # Check for Python dependency files
        req_txt = directory / "requirements.txt"
        if req_txt.exists():
            deps.extend(self.parse_requirements_txt(req_txt))

        pyproject = directory / "pyproject.toml"
        if pyproject.exists():
            deps.extend(self.parse_pyproject_toml(pyproject))

        # Check for Node.js dependency files
        pkg_json = directory / "package.json"
        if pkg_json.exists():
            deps.extend(self.parse_package_json(pkg_json))

        return deps

    def parse_requirements_txt(self, filepath: Path) -> list[Dependency]:
        """Parse requirements.txt file."""
        deps = []
        for line in filepath.read_text().strip().split("\n"):
            line = line.strip()
            # Skip comments and empty lines
            if not line or line.startswith("#") or line.startswith("-"):
                continue

            # Parse package name and version
            # Formats: package, package==1.0, package>=1.0, package[extra]>=1.0
            match = re.match(r"^([a-zA-Z0-9_-]+)(?:\[.*?\])?(?:[=<>!~]+(.+))?$", line)
            if match:
                name = match.group(1).lower()
                version = match.group(2)
                deps.append(
                    Dependency(
                        name=name,
                        version=version,
                        ecosystem="pypi",
                        source_file=str(filepath),
                    )
                )

        return deps

    def parse_package_json(self, filepath: Path) -> list[Dependency]:
        """Parse package.json file."""
        deps = []
        try:
            data = json.loads(filepath.read_text())
        except json.JSONDecodeError:
            return deps

        for dep_type in ["dependencies", "devDependencies"]:
            for name, version_spec in data.get(dep_type, {}).items():
                # Strip version prefixes like ^, ~, >=
                version = re.sub(r"^[\^~>=<]+", "", version_spec)
                deps.append(
                    Dependency(
                        name=name.lower(),
                        version=version if version else None,
                        ecosystem="npm",
                        source_file=str(filepath),
                    )
                )

        return deps

    def parse_pyproject_toml(self, filepath: Path) -> list[Dependency]:
        """Parse pyproject.toml file."""
        deps = []
        content = filepath.read_text()

        # Simple parsing - look for dependencies array
        # Format: dependencies = ["requests>=2.0", "click"]
        match = re.search(r'dependencies\s*=\s*\[(.*?)\]', content, re.DOTALL)
        if match:
            deps_str = match.group(1)
            # Extract quoted strings
            for pkg_match in re.finditer(r'"([^"]+)"', deps_str):
                pkg_spec = pkg_match.group(1)
                # Parse like requirements.txt
                name_match = re.match(r"^([a-zA-Z0-9_-]+)(?:\[.*?\])?(?:[=<>!~]+(.+))?$", pkg_spec)
                if name_match:
                    deps.append(
                        Dependency(
                            name=name_match.group(1).lower(),
                            version=name_match.group(2),
                            ecosystem="pypi",
                            source_file=str(filepath),
                        )
                    )

        return deps
```

**Step 4: Create test __init__.py**

Create `tests/test_deps/__init__.py`:
```python
"""Tests for dependency scanning."""
```

**Step 5: Run tests**

```bash
pytest tests/test_deps/test_parser.py -v
```

**Step 6: Commit**

```bash
git add src/hackmenot/deps/ tests/test_deps/
git commit -m "feat: add dependency file parser"
```

---

## Task 3: Create Hallucination Detector

**Files:**
- Create: `src/hackmenot/deps/hallucination.py`
- Create: `tests/test_deps/test_hallucination.py`

**Step 1: Write failing tests**

Create `tests/test_deps/test_hallucination.py`:
```python
"""Tests for hallucination detection."""

import pytest

from hackmenot.deps.hallucination import HallucinationDetector
from hackmenot.deps.parser import Dependency


class TestHallucinationDetector:
    """Tests for package hallucination detection."""

    def test_known_package_not_flagged(self):
        """Test that known packages are not flagged."""
        detector = HallucinationDetector()
        dep = Dependency(name="requests", version="2.28.0", ecosystem="pypi", source_file="req.txt")

        result = detector.check(dep)

        assert result is None

    def test_unknown_package_flagged(self):
        """Test that unknown packages are flagged."""
        detector = HallucinationDetector()
        dep = Dependency(
            name="nonexistent-ai-hallucinated-pkg-12345",
            version="1.0.0",
            ecosystem="pypi",
            source_file="req.txt",
        )

        result = detector.check(dep)

        assert result is not None
        assert result.rule_id == "DEP001"
        assert "hallucinated" in result.message.lower() or "not found" in result.message.lower()

    def test_npm_known_package(self):
        """Test known npm package not flagged."""
        detector = HallucinationDetector()
        dep = Dependency(name="lodash", version="4.17.0", ecosystem="npm", source_file="package.json")

        result = detector.check(dep)

        assert result is None

    def test_npm_unknown_package(self):
        """Test unknown npm package flagged."""
        detector = HallucinationDetector()
        dep = Dependency(
            name="fake-npm-pkg-xyz-999",
            version="1.0.0",
            ecosystem="npm",
            source_file="package.json",
        )

        result = detector.check(dep)

        assert result is not None
        assert result.rule_id == "DEP001"

    def test_case_insensitive_matching(self):
        """Test that package matching is case-insensitive."""
        detector = HallucinationDetector()
        dep = Dependency(name="Requests", version="2.0", ecosystem="pypi", source_file="req.txt")

        result = detector.check(dep)

        assert result is None
```

**Step 2: Implement detector**

Create `src/hackmenot/deps/hallucination.py`:
```python
"""Hallucination detection for dependencies."""

from hackmenot.core.models import Finding, Severity
from hackmenot.data import load_package_set
from hackmenot.deps.parser import Dependency


class HallucinationDetector:
    """Detect potentially hallucinated (non-existent) packages."""

    def __init__(self) -> None:
        self._pypi_packages: set[str] | None = None
        self._npm_packages: set[str] | None = None

    @property
    def pypi_packages(self) -> set[str]:
        """Lazy-load PyPI package set."""
        if self._pypi_packages is None:
            self._pypi_packages = load_package_set("pypi")
        return self._pypi_packages

    @property
    def npm_packages(self) -> set[str]:
        """Lazy-load npm package set."""
        if self._npm_packages is None:
            self._npm_packages = load_package_set("npm")
        return self._npm_packages

    def check(self, dep: Dependency) -> Finding | None:
        """Check if a dependency might be hallucinated.

        Returns a Finding if the package is not in our known package list,
        or None if the package is known.
        """
        name_lower = dep.name.lower()

        if dep.ecosystem == "pypi":
            packages = self.pypi_packages
        elif dep.ecosystem == "npm":
            packages = self.npm_packages
        else:
            return None

        # If package list is empty (not loaded), skip check
        if not packages:
            return None

        if name_lower not in packages:
            return Finding(
                rule_id="DEP001",
                rule_name="hallucinated-package",
                severity=Severity.HIGH,
                message=f"Package '{dep.name}' not found in {dep.ecosystem} registry. May be hallucinated by AI.",
                file_path=dep.source_file,
                line_number=0,
                column=0,
                code_snippet=f"{dep.name}=={dep.version}" if dep.version else dep.name,
                fix_suggestion="Verify this package exists. Search for the correct package name on PyPI or npm.",
                education="AI assistants sometimes invent package names that don't exist. "
                "Always verify dependencies exist before adding them to your project.",
            )

        return None
```

**Step 3: Run tests**

```bash
pytest tests/test_deps/test_hallucination.py -v
```

**Step 4: Commit**

```bash
git add src/hackmenot/deps/hallucination.py tests/test_deps/test_hallucination.py
git commit -m "feat: add hallucination detection for dependencies"
```

---

## Task 4: Create Typosquat Detector

**Files:**
- Create: `src/hackmenot/deps/typosquat.py`
- Create: `tests/test_deps/test_typosquat.py`

**Step 1: Write failing tests**

Create `tests/test_deps/test_typosquat.py`:
```python
"""Tests for typosquat detection."""

import pytest

from hackmenot.deps.typosquat import TyposquatDetector
from hackmenot.deps.parser import Dependency


class TestTyposquatDetector:
    """Tests for typosquat detection."""

    def test_exact_match_not_flagged(self):
        """Test that exact package names are not flagged."""
        detector = TyposquatDetector()
        dep = Dependency(name="requests", version="2.0", ecosystem="pypi", source_file="req.txt")

        result = detector.check(dep)

        assert result is None

    def test_typo_flagged(self):
        """Test that typos are flagged."""
        detector = TyposquatDetector()
        dep = Dependency(name="requets", version="1.0", ecosystem="pypi", source_file="req.txt")

        result = detector.check(dep)

        assert result is not None
        assert result.rule_id == "DEP002"
        assert result.severity.name == "CRITICAL"
        assert "requests" in result.message

    def test_npm_typo_flagged(self):
        """Test npm typosquatting detection."""
        detector = TyposquatDetector()
        dep = Dependency(name="lodashe", version="1.0", ecosystem="npm", source_file="package.json")

        result = detector.check(dep)

        assert result is not None
        assert "lodash" in result.message

    def test_distant_name_not_flagged(self):
        """Test that very different names are not flagged."""
        detector = TyposquatDetector()
        dep = Dependency(name="mycompanylib", version="1.0", ecosystem="pypi", source_file="req.txt")

        result = detector.check(dep)

        # Should not match any popular package
        assert result is None

    def test_levenshtein_distance_threshold(self):
        """Test that distance > 2 is not flagged."""
        detector = TyposquatDetector()
        # "requests" -> "requxxxx" has distance 4
        dep = Dependency(name="requxxxx", version="1.0", ecosystem="pypi", source_file="req.txt")

        result = detector.check(dep)

        assert result is None
```

**Step 2: Implement detector**

Create `src/hackmenot/deps/typosquat.py`:
```python
"""Typosquat detection for dependencies."""

from hackmenot.core.models import Finding, Severity
from hackmenot.data import load_package_set
from hackmenot.deps.parser import Dependency


def levenshtein_distance(s1: str, s2: str) -> int:
    """Calculate Levenshtein distance between two strings."""
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)

    if len(s2) == 0:
        return len(s1)

    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            # Calculate insertions, deletions, substitutions
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row

    return previous_row[-1]


# Popular packages to check against (top ~100 most downloaded)
POPULAR_PYPI = {
    "requests", "numpy", "pandas", "boto3", "urllib3", "setuptools",
    "typing-extensions", "botocore", "certifi", "idna", "charset-normalizer",
    "python-dateutil", "pip", "pyyaml", "packaging", "s3transfer",
    "six", "cryptography", "cffi", "wheel", "pycparser", "jmespath",
    "pytz", "attrs", "click", "importlib-metadata", "zipp", "platformdirs",
    "filelock", "colorama", "virtualenv", "awscli", "pillow", "protobuf",
    "jinja2", "markupsafe", "rsa", "pyasn1", "docutils", "grpcio",
    "scipy", "google-api-core", "fsspec", "tomli", "pyparsing", "aiohttp",
    "flask", "django", "fastapi", "sqlalchemy", "pytest", "selenium",
}

POPULAR_NPM = {
    "lodash", "react", "express", "axios", "typescript", "moment",
    "chalk", "commander", "debug", "uuid", "async", "request",
    "underscore", "webpack", "babel-core", "eslint", "jest", "mocha",
    "gulp", "grunt", "next", "vue", "angular", "jquery", "rxjs",
    "fs-extra", "glob", "minimist", "yargs", "dotenv", "cors",
    "body-parser", "mongoose", "sequelize", "passport", "socket.io",
    "redis", "mysql", "pg", "mongodb", "graphql", "apollo-server",
}


class TyposquatDetector:
    """Detect potential typosquatting attacks in dependencies."""

    MAX_DISTANCE = 2  # Maximum Levenshtein distance to flag

    def __init__(self) -> None:
        self._pypi_packages: set[str] | None = None
        self._npm_packages: set[str] | None = None

    def check(self, dep: Dependency) -> Finding | None:
        """Check if a dependency might be a typosquat.

        Returns a Finding if the package name is suspiciously similar
        to a popular package, or None otherwise.
        """
        name_lower = dep.name.lower()

        if dep.ecosystem == "pypi":
            popular = POPULAR_PYPI
        elif dep.ecosystem == "npm":
            popular = POPULAR_NPM
        else:
            return None

        # Don't flag exact matches
        if name_lower in popular:
            return None

        # Check distance to each popular package
        for popular_pkg in popular:
            distance = levenshtein_distance(name_lower, popular_pkg)
            if 0 < distance <= self.MAX_DISTANCE:
                return Finding(
                    rule_id="DEP002",
                    rule_name="typosquat-package",
                    severity=Severity.CRITICAL,
                    message=f"Package '{dep.name}' is similar to '{popular_pkg}'. Possible typosquatting attack.",
                    file_path=dep.source_file,
                    line_number=0,
                    column=0,
                    code_snippet=f"{dep.name}=={dep.version}" if dep.version else dep.name,
                    fix_suggestion=f"Did you mean '{popular_pkg}'? Verify the package name is correct.",
                    education="Typosquatting is when attackers publish malicious packages with names "
                    "similar to popular packages. AI assistants may accidentally suggest these. "
                    "Always verify package names carefully.",
                )

        return None
```

**Step 3: Run tests**

```bash
pytest tests/test_deps/test_typosquat.py -v
```

**Step 4: Commit**

```bash
git add src/hackmenot/deps/typosquat.py tests/test_deps/test_typosquat.py
git commit -m "feat: add typosquat detection for dependencies"
```

---

## Task 5: Create OSV Vulnerability Checker

**Files:**
- Create: `src/hackmenot/deps/vulns.py`
- Create: `tests/test_deps/test_vulns.py`

**Step 1: Write failing tests**

Create `tests/test_deps/test_vulns.py`:
```python
"""Tests for vulnerability checking via OSV API."""

from unittest.mock import Mock, patch

import pytest

from hackmenot.deps.vulns import OSVClient
from hackmenot.deps.parser import Dependency


class TestOSVClient:
    """Tests for OSV API client."""

    def test_check_no_vulnerabilities(self):
        """Test package with no known vulnerabilities."""
        client = OSVClient()
        dep = Dependency(name="requests", version="2.31.0", ecosystem="pypi", source_file="req.txt")

        with patch("hackmenot.deps.vulns.urllib.request.urlopen") as mock_urlopen:
            mock_response = Mock()
            mock_response.read.return_value = b'{"vulns": []}'
            mock_response.__enter__ = Mock(return_value=mock_response)
            mock_response.__exit__ = Mock(return_value=False)
            mock_urlopen.return_value = mock_response

            results = client.check(dep)

        assert results == []

    def test_check_with_vulnerability(self):
        """Test package with known vulnerability."""
        client = OSVClient()
        dep = Dependency(name="requests", version="2.25.0", ecosystem="pypi", source_file="req.txt")

        vuln_response = {
            "vulns": [
                {
                    "id": "GHSA-1234-5678-90ab",
                    "summary": "Test vulnerability",
                    "severity": [{"type": "CVSS_V3", "score": "7.5"}],
                    "affected": [{"ranges": [{"events": [{"fixed": "2.26.0"}]}]}],
                }
            ]
        }

        with patch("hackmenot.deps.vulns.urllib.request.urlopen") as mock_urlopen:
            mock_response = Mock()
            mock_response.read.return_value = __import__("json").dumps(vuln_response).encode()
            mock_response.__enter__ = Mock(return_value=mock_response)
            mock_response.__exit__ = Mock(return_value=False)
            mock_urlopen.return_value = mock_response

            results = client.check(dep)

        assert len(results) == 1
        assert results[0].rule_id == "DEP003"
        assert "GHSA-1234-5678-90ab" in results[0].message

    def test_network_error_returns_empty(self):
        """Test that network errors return empty list, not exception."""
        client = OSVClient()
        dep = Dependency(name="requests", version="2.0", ecosystem="pypi", source_file="req.txt")

        with patch("hackmenot.deps.vulns.urllib.request.urlopen") as mock_urlopen:
            mock_urlopen.side_effect = Exception("Network error")

            results = client.check(dep)

        assert results == []

    def test_batch_check(self):
        """Test batch vulnerability checking."""
        client = OSVClient()
        deps = [
            Dependency(name="requests", version="2.0", ecosystem="pypi", source_file="req.txt"),
            Dependency(name="flask", version="1.0", ecosystem="pypi", source_file="req.txt"),
        ]

        with patch("hackmenot.deps.vulns.urllib.request.urlopen") as mock_urlopen:
            mock_response = Mock()
            mock_response.read.return_value = b'{"results": [{"vulns": []}, {"vulns": []}]}'
            mock_response.__enter__ = Mock(return_value=mock_response)
            mock_response.__exit__ = Mock(return_value=False)
            mock_urlopen.return_value = mock_response

            results = client.check_batch(deps)

        assert len(results) == 0
```

**Step 2: Implement OSV client**

Create `src/hackmenot/deps/vulns.py`:
```python
"""Vulnerability checking via OSV API."""

import json
import urllib.request
from urllib.error import URLError

from hackmenot.core.models import Finding, Severity
from hackmenot.deps.parser import Dependency


class OSVClient:
    """Client for querying Open Source Vulnerabilities (OSV) API."""

    API_URL = "https://api.osv.dev/v1/query"
    BATCH_API_URL = "https://api.osv.dev/v1/querybatch"
    TIMEOUT = 10  # seconds

    def _ecosystem_name(self, ecosystem: str) -> str:
        """Convert our ecosystem name to OSV ecosystem name."""
        mapping = {
            "pypi": "PyPI",
            "npm": "npm",
        }
        return mapping.get(ecosystem, ecosystem)

    def _severity_from_cvss(self, score: float) -> Severity:
        """Map CVSS score to severity level."""
        if score >= 9.0:
            return Severity.CRITICAL
        elif score >= 7.0:
            return Severity.HIGH
        elif score >= 4.0:
            return Severity.MEDIUM
        else:
            return Severity.LOW

    def check(self, dep: Dependency) -> list[Finding]:
        """Check a single dependency for vulnerabilities."""
        if dep.version is None:
            return []  # Can't check without version

        query = {
            "package": {
                "name": dep.name,
                "ecosystem": self._ecosystem_name(dep.ecosystem),
            },
            "version": dep.version,
        }

        try:
            req = urllib.request.Request(
                self.API_URL,
                data=json.dumps(query).encode(),
                headers={"Content-Type": "application/json"},
                method="POST",
            )
            with urllib.request.urlopen(req, timeout=self.TIMEOUT) as response:
                data = json.loads(response.read())
        except (URLError, TimeoutError, json.JSONDecodeError):
            return []

        return self._parse_vulns(dep, data.get("vulns", []))

    def check_batch(self, deps: list[Dependency]) -> list[Finding]:
        """Check multiple dependencies for vulnerabilities in one request."""
        # Filter deps without versions
        deps_with_versions = [d for d in deps if d.version is not None]
        if not deps_with_versions:
            return []

        queries = [
            {
                "package": {
                    "name": d.name,
                    "ecosystem": self._ecosystem_name(d.ecosystem),
                },
                "version": d.version,
            }
            for d in deps_with_versions
        ]

        try:
            req = urllib.request.Request(
                self.BATCH_API_URL,
                data=json.dumps({"queries": queries}).encode(),
                headers={"Content-Type": "application/json"},
                method="POST",
            )
            with urllib.request.urlopen(req, timeout=self.TIMEOUT) as response:
                data = json.loads(response.read())
        except (URLError, TimeoutError, json.JSONDecodeError):
            return []

        findings = []
        for dep, result in zip(deps_with_versions, data.get("results", [])):
            findings.extend(self._parse_vulns(dep, result.get("vulns", [])))

        return findings

    def _parse_vulns(self, dep: Dependency, vulns: list[dict]) -> list[Finding]:
        """Parse OSV vulnerability data into Findings."""
        findings = []
        for vuln in vulns:
            vuln_id = vuln.get("id", "Unknown")
            summary = vuln.get("summary", "No description available")

            # Get severity from CVSS score if available
            severity = Severity.MEDIUM  # Default
            for sev in vuln.get("severity", []):
                if sev.get("type") == "CVSS_V3":
                    try:
                        score = float(sev.get("score", "0").split("/")[0])
                        severity = self._severity_from_cvss(score)
                    except (ValueError, IndexError):
                        pass

            # Get fixed version if available
            fix_version = None
            for affected in vuln.get("affected", []):
                for range_info in affected.get("ranges", []):
                    for event in range_info.get("events", []):
                        if "fixed" in event:
                            fix_version = event["fixed"]

            fix_suggestion = f"Upgrade to version {fix_version}" if fix_version else "Check for available patches"

            findings.append(
                Finding(
                    rule_id="DEP003",
                    rule_name="vulnerable-dependency",
                    severity=severity,
                    message=f"Vulnerability {vuln_id} in {dep.name}@{dep.version}: {summary}",
                    file_path=dep.source_file,
                    line_number=0,
                    column=0,
                    code_snippet=f"{dep.name}=={dep.version}",
                    fix_suggestion=fix_suggestion,
                    education="This dependency has a known security vulnerability. "
                    "Update to a patched version or find an alternative package.",
                )
            )

        return findings
```

**Step 3: Run tests**

```bash
pytest tests/test_deps/test_vulns.py -v
```

**Step 4: Commit**

```bash
git add src/hackmenot/deps/vulns.py tests/test_deps/test_vulns.py
git commit -m "feat: add OSV vulnerability checker for dependencies"
```

---

## Task 6: Create Dependency Scanner and CLI Command

**Files:**
- Create: `src/hackmenot/deps/scanner.py`
- Modify: `src/hackmenot/cli/main.py`
- Create: `tests/test_deps/test_scanner.py`

**Step 1: Write failing tests**

Create `tests/test_deps/test_scanner.py`:
```python
"""Tests for dependency scanner."""

from pathlib import Path

import pytest

from hackmenot.deps.scanner import DependencyScanner


class TestDependencyScanner:
    """Tests for the dependency scanner."""

    def test_scan_finds_hallucinated_package(self, tmp_path: Path):
        """Test scanner finds hallucinated packages."""
        (tmp_path / "requirements.txt").write_text("fake-nonexistent-pkg-xyz\n")

        scanner = DependencyScanner()
        result = scanner.scan(tmp_path)

        assert len(result.findings) >= 1
        assert any(f.rule_id == "DEP001" for f in result.findings)

    def test_scan_finds_typosquat(self, tmp_path: Path):
        """Test scanner finds typosquatted packages."""
        (tmp_path / "requirements.txt").write_text("requets\n")

        scanner = DependencyScanner()
        result = scanner.scan(tmp_path)

        assert len(result.findings) >= 1
        assert any(f.rule_id == "DEP002" for f in result.findings)

    def test_scan_clean_dependencies(self, tmp_path: Path):
        """Test scanner with clean dependencies."""
        (tmp_path / "requirements.txt").write_text("requests\nflask\n")

        scanner = DependencyScanner()
        result = scanner.scan(tmp_path)

        # Should not find hallucination or typosquat issues
        assert not any(f.rule_id in ["DEP001", "DEP002"] for f in result.findings)

    def test_scan_no_dependency_files(self, tmp_path: Path):
        """Test scanner with no dependency files."""
        scanner = DependencyScanner()
        result = scanner.scan(tmp_path)

        assert result.files_scanned == 0
        assert len(result.findings) == 0

    def test_scan_mixed_ecosystems(self, tmp_path: Path):
        """Test scanner with both Python and npm dependencies."""
        (tmp_path / "requirements.txt").write_text("requests\n")
        (tmp_path / "package.json").write_text('{"dependencies": {"lodash": "4.0.0"}}')

        scanner = DependencyScanner()
        result = scanner.scan(tmp_path)

        assert result.files_scanned == 2
```

**Step 2: Implement scanner**

Create `src/hackmenot/deps/scanner.py`:
```python
"""Main dependency scanner."""

import time
from pathlib import Path

from hackmenot.core.models import ScanResult
from hackmenot.deps.hallucination import HallucinationDetector
from hackmenot.deps.parser import DependencyParser
from hackmenot.deps.typosquat import TyposquatDetector
from hackmenot.deps.vulns import OSVClient


class DependencyScanner:
    """Scanner for dependency security issues."""

    def __init__(self) -> None:
        self.parser = DependencyParser()
        self.hallucination_detector = HallucinationDetector()
        self.typosquat_detector = TyposquatDetector()
        self.osv_client = OSVClient()

    def scan(
        self,
        directory: Path,
        check_vulns: bool = False,
    ) -> ScanResult:
        """Scan dependencies in a directory.

        Args:
            directory: Directory to scan for dependency files
            check_vulns: Whether to check for CVEs via OSV API

        Returns:
            ScanResult with any findings
        """
        start_time = time.time()
        findings = []
        files_scanned = 0

        # Parse all dependency files
        deps = self.parser.parse_directory(directory)

        # Count unique files
        files_scanned = len(set(d.source_file for d in deps))

        # Check each dependency
        for dep in deps:
            # Hallucination check
            finding = self.hallucination_detector.check(dep)
            if finding:
                findings.append(finding)
                continue  # Skip typosquat check if hallucinated

            # Typosquat check
            finding = self.typosquat_detector.check(dep)
            if finding:
                findings.append(finding)

        # Vulnerability check (optional, requires network)
        if check_vulns and deps:
            vuln_findings = self.osv_client.check_batch(deps)
            findings.extend(vuln_findings)

        scan_time_ms = (time.time() - start_time) * 1000

        return ScanResult(
            files_scanned=files_scanned,
            findings=findings,
            scan_time_ms=scan_time_ms,
        )
```

**Step 3: Update deps __init__.py**

Update `src/hackmenot/deps/__init__.py`:
```python
"""Dependency scanning module."""

from hackmenot.deps.parser import Dependency, DependencyParser
from hackmenot.deps.scanner import DependencyScanner

__all__ = ["Dependency", "DependencyParser", "DependencyScanner"]
```

**Step 4: Add CLI command**

Add to `src/hackmenot/cli/main.py` after the `rules` command:

```python
@app.command()
def deps(
    path: Path = typer.Argument(
        ...,
        help="Directory to scan for dependency files",
    ),
    check_vulns: bool = typer.Option(
        False,
        "--check-vulns",
        help="Check for known vulnerabilities via OSV API (requires internet)",
    ),
    format: OutputFormat = typer.Option(
        OutputFormat.terminal,
        "--format",
        "-f",
        help="Output format",
    ),
    fail_on: str = typer.Option(
        "high",
        "--fail-on",
        help="Minimum severity to return non-zero exit code",
    ),
    ci: bool = typer.Option(
        False,
        "--ci",
        help="CI-friendly output (no colors, machine-readable exit codes)",
    ),
) -> None:
    """Scan dependencies for security issues."""
    from hackmenot.deps.scanner import DependencyScanner

    scan_console = Console(force_terminal=False, no_color=True) if ci else console

    if not path.exists():
        scan_console.print(f"Error: Path does not exist: {path}")
        raise typer.Exit(1)

    if not path.is_dir():
        scan_console.print(f"Error: Path must be a directory: {path}")
        raise typer.Exit(1)

    try:
        scanner = DependencyScanner()
        result = scanner.scan(path, check_vulns=check_vulns)

        # Output results
        if format == OutputFormat.terminal:
            reporter = TerminalReporter(console=scan_console)
            reporter.render(result)
        elif format == OutputFormat.json:
            _output_json(result)
        elif format == OutputFormat.sarif:
            from hackmenot.reporters.sarif import SARIFReporter
            reporter = SARIFReporter()
            print(reporter.render(result))

    except Exception as e:
        if ci:
            scan_console.print(f"Error during scan: {e}")
            raise typer.Exit(2)
        raise

    # Exit code based on findings
    try:
        fail_severity = Severity.from_string(fail_on)
    except KeyError:
        scan_console.print(f"Error: Invalid severity level: {fail_on}")
        raise typer.Exit(1)

    if result.findings_at_or_above(fail_severity):
        raise typer.Exit(1)
```

**Step 5: Run tests**

```bash
pytest tests/test_deps/ -v
```

**Step 6: Commit**

```bash
git add src/hackmenot/deps/ src/hackmenot/cli/main.py tests/test_deps/
git commit -m "feat: add deps command for dependency scanning"
```

---

## Task 7: Add --include-deps Flag to scan Command

**Files:**
- Modify: `src/hackmenot/cli/main.py`
- Create: `tests/test_cli/test_include_deps.py`

**Step 1: Write failing tests**

Create `tests/test_cli/test_include_deps.py`:
```python
"""Tests for --include-deps flag."""

from pathlib import Path

from typer.testing import CliRunner

from hackmenot.cli.main import app

runner = CliRunner()


def test_include_deps_scans_dependencies(tmp_path: Path):
    """Test --include-deps includes dependency scanning."""
    (tmp_path / "app.py").write_text("x = 1")
    (tmp_path / "requirements.txt").write_text("requets\n")  # Typosquat

    result = runner.invoke(app, ["scan", str(tmp_path), "--include-deps"])

    assert "DEP002" in result.stdout or "typosquat" in result.stdout.lower()


def test_without_include_deps_skips_dependencies(tmp_path: Path):
    """Test that without --include-deps, dependencies are not scanned."""
    (tmp_path / "app.py").write_text("x = 1")
    (tmp_path / "requirements.txt").write_text("requets\n")  # Typosquat

    result = runner.invoke(app, ["scan", str(tmp_path)])

    # Should not find dependency issues
    assert "DEP002" not in result.stdout


def test_include_deps_with_clean_deps(tmp_path: Path):
    """Test --include-deps with clean dependencies."""
    (tmp_path / "app.py").write_text("x = 1")
    (tmp_path / "requirements.txt").write_text("requests\n")

    result = runner.invoke(app, ["scan", str(tmp_path), "--include-deps"])

    assert result.exit_code == 0
```

**Step 2: Add --include-deps flag**

Update the `scan` command in `src/hackmenot/cli/main.py`:

Add the parameter:
```python
    include_deps: bool = typer.Option(
        False,
        "--include-deps",
        help="Also scan dependency files for security issues",
    ),
```

Add logic after code scanning (before output):
```python
    # Include dependency scanning if requested
    if include_deps:
        from hackmenot.deps.scanner import DependencyScanner
        dep_scanner = DependencyScanner()
        # Get project directory
        project_dir = scan_paths[0].parent if scan_paths[0].is_file() else scan_paths[0]
        dep_result = dep_scanner.scan(project_dir)
        # Merge findings
        result = ScanResult(
            files_scanned=result.files_scanned + dep_result.files_scanned,
            findings=result.findings + dep_result.findings,
            scan_time_ms=result.scan_time_ms + dep_result.scan_time_ms,
        )
```

**Step 3: Run tests**

```bash
pytest tests/test_cli/test_include_deps.py -v
```

**Step 4: Commit**

```bash
git add src/hackmenot/cli/main.py tests/test_cli/test_include_deps.py
git commit -m "feat: add --include-deps flag to scan command"
```

---

## Task 8: Populate Package Lists

**Files:**
- Modify: `src/hackmenot/data/pypi_top50k.txt`
- Modify: `src/hackmenot/data/npm_top50k.txt`

**Step 1: Populate PyPI list**

Add top PyPI packages to `src/hackmenot/data/pypi_top50k.txt` (one per line, lowercase). Include at minimum the top 1000 packages:

```
requests
boto3
urllib3
setuptools
typing-extensions
botocore
certifi
idna
charset-normalizer
python-dateutil
pip
pyyaml
packaging
s3transfer
six
cryptography
cffi
wheel
pycparser
jmespath
pytz
attrs
click
importlib-metadata
zipp
platformdirs
filelock
colorama
virtualenv
awscli
pillow
protobuf
jinja2
markupsafe
rsa
pyasn1
docutils
grpcio
scipy
google-api-core
fsspec
tomli
pyparsing
aiohttp
flask
django
fastapi
sqlalchemy
pytest
numpy
pandas
...
```

**Step 2: Populate npm list**

Add top npm packages to `src/hackmenot/data/npm_top50k.txt`:

```
lodash
chalk
request
commander
express
debug
async
bluebird
moment
react
underscore
uuid
glob
minimist
mkdirp
colors
yargs
through2
q
semver
readable-stream
prop-types
rxjs
ws
inherits
typescript
webpack
axios
babel-runtime
fs-extra
...
```

**Step 3: Commit**

```bash
git add src/hackmenot/data/
git commit -m "feat: populate package lists for hallucination detection"
```

---

## Task 9: Update pyproject.toml

**Files:**
- Modify: `pyproject.toml`

**Step 1: Add package data**

Update `pyproject.toml` to include the data files:

```toml
[tool.hatch.build.targets.wheel]
packages = ["src/hackmenot"]

[tool.hatch.build.targets.wheel.shared-data]
"src/hackmenot/data" = "hackmenot/data"
```

Or if using `package-data`:

```toml
[tool.hatch.build]
include = [
    "src/hackmenot/**/*.py",
    "src/hackmenot/**/*.yml",
    "src/hackmenot/**/*.txt",
]
```

**Step 2: Commit**

```bash
git add pyproject.toml
git commit -m "build: include package data files in distribution"
```

---

## Task 10: Create Documentation - Getting Started

**Files:**
- Create: `docs/getting-started.md`

**Step 1: Write documentation**

Create `docs/getting-started.md`:
```markdown
# Getting Started with hackmenot

hackmenot is an AI-era code security scanner that catches vulnerabilities commonly introduced by AI coding assistants.

## Installation

```bash
pip install hackmenot
```

## Quick Start

### Scan Your Code

```bash
# Scan current directory
hackmenot scan .

# Scan a specific file
hackmenot scan src/app.py

# Scan with JSON output
hackmenot scan . --format json
```

### Scan Dependencies

```bash
# Check for hallucinated and typosquatted packages
hackmenot deps .

# Also check for known vulnerabilities (requires internet)
hackmenot deps . --check-vulns
```

### Understanding Output

hackmenot reports findings with severity levels:

| Severity | Meaning |
|----------|---------|
| **CRITICAL** | Immediate security risk, fix now |
| **HIGH** | Significant vulnerability, prioritize |
| **MEDIUM** | Security concern, should be addressed |
| **LOW** | Minor issue, fix when convenient |

Example output:

```
hackmenot v0.1.0

Scanning 15 files...

CRITICAL  INJ001  src/api.py:42
  SQL injection: query built with f-string interpolation

  query = f"SELECT * FROM users WHERE id = {user_id}"

  Fix: Use parameterized queries instead:
       cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))

Found 1 issue in 15 files (125ms)
```

### Auto-Fix Issues

```bash
# Automatically apply fixes
hackmenot scan . --fix

# Interactively choose which fixes to apply
hackmenot scan . --fix-interactive
```

## Next Steps

- [CLI Reference](cli-reference.md) - All commands and options
- [CI Integration](ci-integration.md) - Set up in your pipeline
- [Configuration](configuration.md) - Customize hackmenot
```

**Step 2: Commit**

```bash
git add docs/getting-started.md
git commit -m "docs: add getting started guide"
```

---

## Task 11: Create Documentation - CLI Reference

**Files:**
- Create: `docs/cli-reference.md`

**Step 1: Write documentation**

Create `docs/cli-reference.md`:
```markdown
# CLI Reference

Complete reference for all hackmenot commands and options.

## Commands

### `hackmenot scan`

Scan code for security vulnerabilities.

```bash
hackmenot scan [PATHS...] [OPTIONS]
```

**Arguments:**
- `PATHS` - Files or directories to scan (default: current directory)

**Options:**
| Option | Description |
|--------|-------------|
| `--format, -f` | Output format: `terminal`, `json`, `sarif` |
| `--severity, -s` | Minimum severity to report: `critical`, `high`, `medium`, `low` |
| `--fail-on` | Minimum severity for non-zero exit: `critical`, `high`, `medium`, `low` |
| `--fix` | Automatically apply all available fixes |
| `--fix-interactive` | Interactively choose fixes to apply |
| `--full` | Bypass cache, perform full scan |
| `--ci` | CI-friendly output (no colors) |
| `--staged` | Scan only git staged files |
| `--pr-comment` | Output markdown for PR comments |
| `--include-deps` | Also scan dependency files |
| `--config, -c` | Path to config file |

**Examples:**
```bash
# Basic scan
hackmenot scan .

# Scan with SARIF output for GitHub
hackmenot scan . --format sarif > results.sarif

# CI mode with strict threshold
hackmenot scan . --ci --fail-on critical

# Pre-commit hook
hackmenot scan --staged --ci
```

### `hackmenot deps`

Scan dependencies for security issues.

```bash
hackmenot deps PATH [OPTIONS]
```

**Arguments:**
- `PATH` - Directory containing dependency files

**Options:**
| Option | Description |
|--------|-------------|
| `--check-vulns` | Check for CVEs via OSV API (requires internet) |
| `--format, -f` | Output format: `terminal`, `json`, `sarif` |
| `--fail-on` | Minimum severity for non-zero exit |
| `--ci` | CI-friendly output |

**Examples:**
```bash
# Basic dependency scan
hackmenot deps .

# Include vulnerability check
hackmenot deps . --check-vulns

# CI mode
hackmenot deps . --check-vulns --ci --fail-on high
```

### `hackmenot rules`

List available security rules.

```bash
hackmenot rules [RULE_ID]
```

**Arguments:**
- `RULE_ID` - Optional rule ID to show details

**Examples:**
```bash
# List all rules
hackmenot rules

# Show details for specific rule
hackmenot rules INJ001
```

## Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Success, no findings at or above fail level |
| 1 | Findings at or above fail level |
| 2 | Error during scan |

## Environment Variables

| Variable | Description |
|----------|-------------|
| `NO_COLOR` | Disable colored output |
| `HACKMENOT_CONFIG` | Path to config file |
```

**Step 2: Commit**

```bash
git add docs/cli-reference.md
git commit -m "docs: add CLI reference"
```

---

## Task 12: Create Documentation - CI Integration

**Files:**
- Create: `docs/ci-integration.md`

**Step 1: Write documentation**

Create `docs/ci-integration.md`:
```markdown
# CI/CD Integration

Integrate hackmenot into your CI/CD pipeline to catch security issues before they reach production.

## GitHub Actions

### Using the Action

```yaml
name: Security Scan
on: [push, pull_request]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: hackmenot/hackmenot-action@v1
        with:
          path: '.'
          fail-on: 'high'
```

### Manual Setup

```yaml
name: Security Scan
on: [push, pull_request]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - run: pip install hackmenot
      - run: hackmenot scan . --ci --fail-on high
```

### SARIF Upload to Code Scanning

```yaml
- run: hackmenot scan . --format sarif > results.sarif
- uses: github/codeql-action/upload-sarif@v3
  with:
    sarif_file: results.sarif
```

## GitLab CI

```yaml
hackmenot:
  image: python:3.11-slim
  stage: test
  script:
    - pip install hackmenot
    - hackmenot scan . --ci --fail-on high
  artifacts:
    reports:
      sast: gl-sast-report.json
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
```

## Pre-commit Hook

Add to `.pre-commit-config.yaml`:

```yaml
repos:
  - repo: https://github.com/hackmenot/hackmenot
    rev: v0.1.0
    hooks:
      - id: hackmenot
```

Or configure manually:

```yaml
repos:
  - repo: local
    hooks:
      - id: hackmenot
        name: hackmenot security scan
        entry: hackmenot scan --staged --ci
        language: system
        pass_filenames: false
```

## Jenkins

```groovy
pipeline {
    agent { docker { image 'python:3.11' } }
    stages {
        stage('Security Scan') {
            steps {
                sh 'pip install hackmenot'
                sh 'hackmenot scan . --ci --fail-on high'
            }
        }
    }
}
```

## CircleCI

```yaml
version: 2.1
jobs:
  security-scan:
    docker:
      - image: cimg/python:3.11
    steps:
      - checkout
      - run: pip install hackmenot
      - run: hackmenot scan . --ci --fail-on high
```

## Azure DevOps

```yaml
trigger: [main]
pool:
  vmImage: 'ubuntu-latest'
steps:
  - task: UsePythonVersion@0
    inputs:
      versionSpec: '3.11'
  - script: |
      pip install hackmenot
      hackmenot scan . --ci --fail-on high
    displayName: 'Security Scan'
```

## Best Practices

1. **Fail on high or critical** - Use `--fail-on high` to block serious issues
2. **Use SARIF** - Upload to GitHub Code Scanning for PR annotations
3. **Pre-commit for speed** - Use `--staged` to only scan changed files
4. **Include dependencies** - Add `hackmenot deps . --check-vulns` to check packages
```

**Step 2: Commit**

```bash
git add docs/ci-integration.md
git commit -m "docs: add CI integration guide"
```

---

## Task 13: Create Documentation - Rules Reference

**Files:**
- Create: `docs/rules-reference.md`

**Step 1: Write documentation**

Create `docs/rules-reference.md`:
```markdown
# Rules Reference

hackmenot includes 55+ security rules across multiple categories.

## Categories

| Category | Description | Rule Count |
|----------|-------------|------------|
| Injection | SQL, command, code injection | 11 |
| Authentication | Missing auth, weak passwords | 8 |
| Cryptography | Weak algorithms, hardcoded keys | 10 |
| Data Exposure | Logging secrets, verbose errors | 7 |
| XSS | Cross-site scripting | 4 |
| Validation | Input validation issues | 8 |
| Dependencies | Hallucinated packages, CVEs | 3 |

## Injection Rules

### INJ001 - SQL Injection (f-string)
- **Severity:** Critical
- **Languages:** Python
- **Description:** SQL query built using f-string with user input

```python
# Bad
query = f"SELECT * FROM users WHERE id = {user_id}"

# Good
cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
```

### INJ002 - Command Injection
- **Severity:** Critical
- **Languages:** Python
- **Description:** Shell command built with f-string

### JSIJ001 - eval() Injection
- **Severity:** Critical
- **Languages:** JavaScript
- **Description:** Use of eval() with potentially untrusted input

```javascript
// Bad
eval(userInput);

// Good
JSON.parse(userInput);
```

## Authentication Rules

### AUTH001 - Missing Authentication
- **Severity:** High
- **Languages:** Python
- **Description:** Route handler missing authentication decorator

### JSAU001 - Hardcoded Secret
- **Severity:** High
- **Languages:** JavaScript
- **Description:** Hardcoded API key or secret in code

## Cryptography Rules

### CRYPTO001 - Weak Hash Algorithm
- **Severity:** High
- **Languages:** Python
- **Description:** Use of MD5 or SHA1 for security purposes

### JSCR001 - Math.random() for Security
- **Severity:** High
- **Languages:** JavaScript
- **Description:** Using Math.random() for tokens or secrets

## XSS Rules

### XSS001 - innerHTML Assignment
- **Severity:** High
- **Languages:** JavaScript
- **Description:** Direct assignment to innerHTML

### XSS002 - dangerouslySetInnerHTML
- **Severity:** High
- **Languages:** JavaScript
- **Description:** Use of React's dangerouslySetInnerHTML

## Dependency Rules

### DEP001 - Hallucinated Package
- **Severity:** High
- **Description:** Package not found in registry (may be AI-invented)

### DEP002 - Typosquat Package
- **Severity:** Critical
- **Description:** Package name similar to popular package (possible attack)

### DEP003 - Vulnerable Dependency
- **Severity:** Varies
- **Description:** Package has known CVE

## Listing All Rules

```bash
# List all rules
hackmenot rules

# Show details for a specific rule
hackmenot rules INJ001
```
```

**Step 2: Commit**

```bash
git add docs/rules-reference.md
git commit -m "docs: add rules reference"
```

---

## Task 14: Create Documentation - Custom Rules

**Files:**
- Create: `docs/custom-rules.md`

**Step 1: Write documentation**

Create `docs/custom-rules.md`:
```markdown
# Custom Rules

Create your own security rules using YAML.

## Rule Structure

```yaml
id: CUSTOM001
name: my-custom-rule
severity: high
category: custom
languages: [python]
description: "Description of what this rule detects"
ai_context: "Why AI assistants commonly make this mistake"

pattern:
  type: fstring  # or 'call', 'string'
  contains: ["dangerous_function"]

message: "Warning message shown to user"

fix:
  template: |
    # How to fix this issue

education: |
  Detailed explanation of the vulnerability
  and how to prevent it.

references:
  - https://example.com/security-guide
```

## Pattern Types

### fstring
Matches f-strings containing specific text:
```yaml
pattern:
  type: fstring
  contains: ["SELECT", "INSERT", "DELETE"]
```

### call
Matches function calls:
```yaml
pattern:
  type: call
  contains: ["eval", "exec"]
```

### string
Matches string literals:
```yaml
pattern:
  type: string
  contains: ["password", "secret"]
```

## Adding Custom Rules

1. Create a `.hackmenot/rules/` directory in your project
2. Add YAML rule files
3. hackmenot will automatically load them

```
myproject/
 .hackmenot/
    rules/
        CUSTOM001.yml
 src/
 ...
```

## Example: API Key Detection

```yaml
id: CUSTOM001
name: hardcoded-api-key
severity: high
category: secrets
languages: [python, javascript]
description: "Hardcoded API key in source code"

pattern:
  type: string
  contains: ["api_key", "apiKey", "API_KEY"]
  exclude: ["os.environ", "process.env"]

message: "Possible hardcoded API key detected"

fix:
  template: |
    # Use environment variables:
    # Python: os.environ.get("API_KEY")
    # JavaScript: process.env.API_KEY

education: |
  Hardcoded API keys can be extracted from source code.
  Always use environment variables or secret managers.
```

## Testing Custom Rules

```bash
# Test with verbose output
hackmenot scan . --severity low

# List loaded rules including custom
hackmenot rules
```
```

**Step 2: Commit**

```bash
git add docs/custom-rules.md
git commit -m "docs: add custom rules guide"
```

---

## Task 15: Create Documentation - Configuration

**Files:**
- Create: `docs/configuration.md`

**Step 1: Write documentation**

Create `docs/configuration.md`:
```markdown
# Configuration

Configure hackmenot using a `hackmenot.yml` file in your project root.

## Configuration File

```yaml
# hackmenot.yml

# Minimum severity to fail on (default: high)
fail_on: high

# Rules to disable
disabled_rules:
  - CRYPTO003  # We use MD5 for non-security purposes
  - AUTH002

# Paths to exclude from scanning
exclude:
  - "tests/**"
  - "docs/**"
  - "**/migrations/**"
  - "*.generated.py"

# Additional rule directories
rule_paths:
  - .hackmenot/rules
  - /shared/security-rules
```

## Options

### fail_on
Minimum severity level that causes non-zero exit code.

```yaml
fail_on: critical  # Only fail on critical issues
fail_on: high      # Fail on high and critical (default)
fail_on: medium    # Fail on medium and above
fail_on: low       # Fail on any issue
```

### disabled_rules
List of rule IDs to skip:

```yaml
disabled_rules:
  - INJ001
  - AUTH001
```

### exclude
Glob patterns for paths to exclude:

```yaml
exclude:
  - "tests/**"
  - "**/*.test.py"
  - "vendor/**"
```

### rule_paths
Additional directories containing custom rules:

```yaml
rule_paths:
  - .hackmenot/rules
  - ~/my-rules
```

## Inline Ignores

Ignore specific lines with comments:

```python
query = f"SELECT * FROM {table}"  # hackmenot: ignore INJ001

# Or ignore all rules on a line:
eval(code)  # hackmenot: ignore
```

```javascript
eval(code); // hackmenot: ignore JSIJ001
```

## Environment Variables

| Variable | Description |
|----------|-------------|
| `HACKMENOT_CONFIG` | Path to config file |
| `NO_COLOR` | Disable colored output |

## Config File Discovery

hackmenot looks for config in this order:
1. `--config` CLI argument
2. `hackmenot.yml` in current directory
3. `hackmenot.yaml` in current directory
4. `.hackmenot.yml` in current directory
5. Default settings
```

**Step 2: Commit**

```bash
git add docs/configuration.md
git commit -m "docs: add configuration guide"
```

---

## Task 16: Create Documentation - Contributing

**Files:**
- Create: `docs/contributing.md`

**Step 1: Write documentation**

Create `docs/contributing.md`:
```markdown
# Contributing to hackmenot

We welcome contributions! Here's how to get started.

## Development Setup

```bash
# Clone the repository
git clone https://github.com/hackmenot/hackmenot.git
cd hackmenot

# Create virtual environment
python -m venv venv
source venv/bin/activate  # or `venv\Scripts\activate` on Windows

# Install in development mode
pip install -e ".[dev]"

# Run tests
pytest
```

## Running Tests

```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=hackmenot

# Run specific test file
pytest tests/test_core/test_scanner.py

# Run tests matching a pattern
pytest -k "test_sql"
```

## Code Style

We use ruff for linting and formatting:

```bash
# Check code
ruff check .

# Format code
ruff format .

# Type checking
mypy src/hackmenot
```

## Adding a New Rule

1. Create YAML file in `src/hackmenot/rules/builtin/<category>/`:

```yaml
id: CAT001
name: rule-name
severity: high
category: category
languages: [python]
description: "What this rule detects"

pattern:
  type: fstring
  contains: ["pattern"]

message: "Warning message"

fix:
  template: |
    # How to fix

education: |
  Why this is a problem
```

2. Add tests in `tests/test_rules/`:

```python
def test_cat001_detects_pattern(tmp_path):
    (tmp_path / "test.py").write_text('vulnerable_code')
    scanner = Scanner()
    result = scanner.scan([tmp_path])
    assert any(f.rule_id == "CAT001" for f in result.findings)
```

3. Run tests and submit PR

## Pull Request Process

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/my-feature`
3. Make your changes
4. Run tests: `pytest`
5. Run linting: `ruff check .`
6. Commit: `git commit -m "feat: add my feature"`
7. Push: `git push origin feature/my-feature`
8. Open a Pull Request

## Commit Messages

Follow conventional commits:
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation
- `test:` - Tests
- `refactor:` - Refactoring
- `chore:` - Maintenance

## Questions?

Open an issue on GitHub or reach out to the maintainers.
```

**Step 2: Commit**

```bash
git add docs/contributing.md
git commit -m "docs: add contributing guide"
```

---

## Task 17: Update README

**Files:**
- Modify: `README.md`

**Step 1: Update README**

Replace `README.md` with:
```markdown
# hackmenot

[![PyPI version](https://badge.fury.io/py/hackmenot.svg)](https://badge.fury.io/py/hackmenot)
[![Tests](https://github.com/hackmenot/hackmenot/actions/workflows/test.yml/badge.svg)](https://github.com/hackmenot/hackmenot/actions)
[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

AI-Era Code Security Scanner - catches the vulnerabilities AI coding assistants commonly introduce.

## Why hackmenot?

**40-62% of AI-generated code contains security flaws.** Traditional SAST tools weren't built for the patterns AI produces. hackmenot applies AI-aware security rules to all code, providing not just warnings but **fixes and education**.

## Features

- **55+ Security Rules** - Purpose-built for vulnerabilities Copilot, Cursor, Claude Code introduce
- **Fix, Don't Nag** - Every finding includes auto-fix suggestions
- **Developer Education** - Explains *why* AI makes this mistake
- **Dependency Scanning** - Detects hallucinated packages and typosquats
- **Sub-second Scans** - Incremental scanning makes pre-commit hooks instant
- **Zero Config** - Works immediately on Python and JavaScript/TypeScript

## Quick Start

```bash
pip install hackmenot

# Scan your code
hackmenot scan .

# Scan dependencies
hackmenot deps .

# Auto-fix issues
hackmenot scan . --fix-interactive
```

## What It Catches

| Category | Examples |
|----------|----------|
| **Injection** | SQL injection, command injection, XSS |
| **Authentication** | Missing auth decorators, weak sessions |
| **Cryptography** | Weak algorithms, hardcoded keys |
| **Data Exposure** | Logging secrets, verbose errors |
| **Dependencies** | Hallucinated packages, typosquats, CVEs |

### Example

```
$ hackmenot scan .

CRITICAL  INJ001  src/api.py:42
  SQL injection: query built with f-string interpolation

  query = f"SELECT * FROM users WHERE id = {user_id}"

  Fix: Use parameterized queries:
       cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))

Found 1 issue in 15 files (125ms)
```

## CI/CD Integration

### GitHub Actions

```yaml
- uses: hackmenot/hackmenot-action@v1
  with:
    fail-on: high
```

### Pre-commit

```yaml
repos:
  - repo: https://github.com/hackmenot/hackmenot
    rev: v0.1.0
    hooks:
      - id: hackmenot
```

See [CI Integration Guide](docs/ci-integration.md) for GitLab, Jenkins, and more.

## Documentation

- [Getting Started](docs/getting-started.md)
- [CLI Reference](docs/cli-reference.md)
- [Rules Reference](docs/rules-reference.md)
- [Configuration](docs/configuration.md)
- [CI Integration](docs/ci-integration.md)
- [Custom Rules](docs/custom-rules.md)
- [Contributing](docs/contributing.md)

## License

Apache 2.0
```

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: update README for v1.0"
```

---

## Task 18: Integration Tests

**Files:**
- Create: `tests/test_deps/test_integration.py`

**Step 1: Write integration tests**

Create `tests/test_deps/test_integration.py`:
```python
"""Integration tests for dependency scanning."""

from pathlib import Path

from typer.testing import CliRunner

from hackmenot.cli.main import app
from hackmenot.deps.scanner import DependencyScanner

runner = CliRunner()


class TestDependencyIntegration:
    """End-to-end tests for dependency scanning."""

    def test_full_scan_python_project(self, tmp_path: Path):
        """Test full dependency scan on Python project."""
        (tmp_path / "requirements.txt").write_text(
            "requests==2.31.0\n"
            "flask==2.0.0\n"
            "fake-hallucinated-pkg\n"
            "requets==1.0.0\n"  # Typosquat
        )

        result = runner.invoke(app, ["deps", str(tmp_path)])

        assert "DEP001" in result.stdout  # Hallucinated
        assert "DEP002" in result.stdout  # Typosquat

    def test_full_scan_npm_project(self, tmp_path: Path):
        """Test full dependency scan on npm project."""
        (tmp_path / "package.json").write_text(
            '{"dependencies": {"lodash": "4.17.0", "lodashe": "1.0.0"}}'
        )

        result = runner.invoke(app, ["deps", str(tmp_path)])

        assert "DEP002" in result.stdout  # Typosquat

    def test_deps_command_json_output(self, tmp_path: Path):
        """Test deps command with JSON output."""
        (tmp_path / "requirements.txt").write_text("requests\n")

        result = runner.invoke(app, ["deps", str(tmp_path), "--format", "json"])

        import json
        data = json.loads(result.stdout)
        assert "files_scanned" in data
        assert "findings" in data

    def test_deps_command_ci_mode(self, tmp_path: Path):
        """Test deps command in CI mode."""
        (tmp_path / "requirements.txt").write_text("requests\n")

        result = runner.invoke(app, ["deps", str(tmp_path), "--ci"])

        # No ANSI codes
        assert "\x1b[" not in result.stdout

    def test_scan_with_include_deps(self, tmp_path: Path):
        """Test scan command with --include-deps."""
        (tmp_path / "app.py").write_text('query = f"SELECT * FROM {x}"')
        (tmp_path / "requirements.txt").write_text("requets\n")  # Typosquat

        result = runner.invoke(app, ["scan", str(tmp_path), "--include-deps"])

        assert "INJ001" in result.stdout  # Code issue
        assert "DEP002" in result.stdout  # Dependency issue

    def test_mixed_project_full_scan(self, tmp_path: Path):
        """Test full scan of mixed Python/JS project with deps."""
        (tmp_path / "app.py").write_text("x = 1")
        (tmp_path / "app.js").write_text("const x = 1;")
        (tmp_path / "requirements.txt").write_text("requests\n")
        (tmp_path / "package.json").write_text('{"dependencies": {"lodash": "4.0.0"}}')

        result = runner.invoke(app, ["scan", str(tmp_path), "--include-deps"])

        assert result.exit_code == 0  # No issues
```

**Step 2: Run tests**

```bash
pytest tests/test_deps/test_integration.py -v
```

**Step 3: Commit**

```bash
git add tests/test_deps/test_integration.py
git commit -m "test: add dependency scanning integration tests"
```

---

## Summary

**Total Tasks:** 18
**Expected Tests:** ~30 new tests
**New Files:** ~20 files

**Key Deliverables:**
1. Package database (PyPI + npm top 50K)
2. Dependency parser (requirements.txt, package.json, pyproject.toml)
3. Hallucination detector (DEP001)
4. Typosquat detector (DEP002)
5. OSV vulnerability checker (DEP003)
6. `hackmenot deps` command
7. `--include-deps` flag for scan
8. 7 documentation files
9. Updated README
10. Integration tests
